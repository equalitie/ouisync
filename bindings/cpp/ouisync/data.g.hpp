// This file is auto generated. Do not edit.

#pragma once

#include <cstdint>
#include <list>
#include <optional>
#include <memory>
#include <sstream>
#include <chrono>
#include <variant>

namespace ouisync {


/**
 * Symmetric encryption/decryption secret key.
 *
 * Note: this implementation tries to prevent certain types of attacks by making sure the
 * underlying sensitive key material is always stored at most in one place. This is achieved by
 * putting it on the heap which means it is not moved when the key itself is moved which could
 * otherwise leave a copy of the data in memory. Additionally, the data is behind a `Arc` which
 * means the key can be cheaply cloned without actually cloning the data. Finally, the data is
 * scrambled (overwritten with zeros) when the key is dropped to make sure it does not stay in
 * the memory past its lifetime.
 */
struct SecretKey {
    std::vector<uint8_t> value;
};

/**
 * A simple wrapper over String to avoid certain kinds of attack. For more elaboration please see
 * the documentation for the SecretKey structure.
 */
struct Password {
    std::string value;
};

struct PasswordSalt {
    std::vector<uint8_t> value;
};

/**
 * Strongly typed storage size.
 */
struct StorageSize {
    uint64_t bytes;
};

/**
 * Access mode of a repository.
 */
enum AccessMode : uint8_t {
    /**
     * Repository is neither readable not writtable (but can still be synced).
     */
    BLIND = 0,
    /**
     * Repository is readable but not writtable.
     */
    READ = 1,
    /**
     * Repository is both readable and writable.
     */
    WRITE = 2,
};


/**
 * Type of secret to unlock a repository.
 */
struct LocalSecret {
    /**
     * Password provided by the user
     */
    struct Password {
        ouisync::Password value;
    };

    /**
     * Secret key generated by secure means (e.g., crypto-secure RNG, KDF, ...)
     */
    struct SecretKey {
        ouisync::SecretKey value;
    };

    using Alternatives = std::variant<
        Password,
        SecretKey
    >;

    Alternatives value;

    LocalSecret() = default;
    LocalSecret(LocalSecret&&) = default;
    LocalSecret& operator=(LocalSecret&&) = default;
    LocalSecret(LocalSecret const&) = default;

    template<class T>
    LocalSecret(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }

};
/**
 * Used to set or change the read or write local secret of a repository.
 */
struct SetLocalSecret {
    /**
     * Password provided by the user
     */
    struct Password {
        ouisync::Password value;
    };

    /**
     * Use to directly (without doing password hashing) set the `SecretKey` and `PasswordSalt` for
     * read or write access.
     */
    struct KeyAndSalt {
        ouisync::SecretKey key;
        ouisync::PasswordSalt salt;
    };

    using Alternatives = std::variant<
        Password,
        KeyAndSalt
    >;

    Alternatives value;

    SetLocalSecret() = default;
    SetLocalSecret(SetLocalSecret&&) = default;
    SetLocalSecret& operator=(SetLocalSecret&&) = default;
    SetLocalSecret(SetLocalSecret const&) = default;

    template<class T>
    SetLocalSecret(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }

};
/**
 * Token to share a repository. It can be encoded as a URL-formatted string and transmitted to
 * other replicas.
 */
struct ShareToken {
    std::string value;
};

/**
 * How to change access to a repository.
 */
struct AccessChange {
    /**
     * Enable read or write access, optionally with local secret
     */
    struct Enable {
        std::optional<ouisync::SetLocalSecret> value;
    };

    /**
     * Disable access
     */
    struct Disable {
    };

    using Alternatives = std::variant<
        Enable,
        Disable
    >;

    Alternatives value;

    AccessChange() = default;
    AccessChange(AccessChange&&) = default;
    AccessChange& operator=(AccessChange&&) = default;
    AccessChange(AccessChange const&) = default;

    template<class T>
    AccessChange(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }

};
/**
 * Type of filesystem entry.
 */
enum EntryType : uint8_t {
    FILE = 1,
    DIRECTORY = 2,
};


/**
 * Network notification event.
 */
enum NetworkEvent : uint8_t {
    /**
     * A peer has appeared with higher protocol version than us. Probably means we are using
     * outdated library. This event can be used to notify the user that they should update the app.
     */
    PROTOCOL_VERSION_MISMATCH = 0,
    /**
     * The set of known peers has changed (e.g., a new peer has been discovered)
     */
    PEER_SET_CHANGE = 1,
};


/**
 * How was the peer discovered.
 */
enum PeerSource : uint8_t {
    /**
     * Explicitly added by the user.
     */
    USER_PROVIDED = 0,
    /**
     * Peer connected to us.
     */
    LISTENER = 1,
    /**
     * Discovered on the Local Discovery.
     */
    LOCAL_DISCOVERY = 2,
    /**
     * Discovered on the DHT.
     */
    DHT = 3,
    /**
     * Discovered on the Peer Exchange.
     */
    PEER_EXCHANGE = 4,
};


struct PublicRuntimeId {
    std::vector<uint8_t> value;
};

struct PeerState {
    struct Known {
    };

    struct Connecting {
    };

    struct Handshaking {
    };

    struct Active {
        ouisync::PublicRuntimeId id;
        std::chrono::time_point<std::chrono::system_clock> since;
    };

    using Alternatives = std::variant<
        Known,
        Connecting,
        Handshaking,
        Active
    >;

    Alternatives value;

    PeerState() = default;
    PeerState(PeerState&&) = default;
    PeerState& operator=(PeerState&&) = default;
    PeerState(PeerState const&) = default;

    template<class T>
    PeerState(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }

};
/**
 * Network traffic statistics.
 */
struct Stats {
    uint64_t bytes_tx;
    uint64_t bytes_rx;
    uint64_t throughput_tx;
    uint64_t throughput_rx;
};

/**
 * Information about a peer.
 */
struct PeerInfo {
    std::string addr;
    PeerSource source;
    PeerState state;
    Stats stats;
};

/**
 * Progress of a task.
 */
struct Progress {
    uint64_t value;
    uint64_t total;
};

enum NatBehavior : uint8_t {
    ENDPOINT_INDEPENDENT = 0,
    ADDRESS_DEPENDENT = 1,
    ADDRESS_AND_PORT_DEPENDENT = 2,
};


namespace error {
enum Service : uint16_t {
    /**
     * No error
     */
    OK = 0,
    /**
     * Insuficient permission to perform the intended operation
     */
    PERMISSION_DENIED = 1,
    /**
     * Invalid input parameter
     */
    INVALID_INPUT = 2,
    /**
     * Invalid data (e.g., malformed incoming message, config file, etc...)
     */
    INVALID_DATA = 3,
    /**
     * Entry already exists
     */
    ALREADY_EXISTS = 4,
    /**
     * Entry not found
     */
    NOT_FOUND = 5,
    /**
     * Multiple matching entries found
     */
    AMBIGUOUS = 6,
    /**
     * The indended operation is not supported
     */
    UNSUPPORTED = 8,
    /**
     * The operation was interrupted
     */
    INTERRUPTED = 9,
    /**
     * Failed to establish connection to the server
     */
    CONNECTION_REFUSED = 1025,
    /**
     * Connection aborted by the server
     */
    CONNECTION_ABORTED = 1026,
    /**
     * Failed to send or receive message
     */
    TRANSPORT_ERROR = 1027,
    /**
     * Listener failed to bind to the specified address
     */
    LISTENER_BIND_ERROR = 1028,
    /**
     * Listener failed to accept client connection
     */
    LISTENER_ACCEPT_ERROR = 1029,
    /**
     * Operation on the internal repository store failed
     */
    STORE_ERROR = 2049,
    /**
     * Entry was expected to not be a directory but it is
     */
    IS_DIRECTORY = 2050,
    /**
     * Entry was expected to be a directory but it isn't
     */
    NOT_DIRECTORY = 2051,
    /**
     * Directory was expected to be empty but it isn't
     */
    DIRECTORY_NOT_EMPTY = 2052,
    /**
     * File or directory is busy
     */
    RESOURCE_BUSY = 2053,
    /**
     * Failed to initialize runtime
     */
    RUNTIME_INITIALIZE_ERROR = 4097,
    /**
     * Failed to read from or write into the config file
     */
    CONFIG_ERROR = 4099,
    /**
     * TLS certificated not found
     */
    TLS_CERTIFICATES_NOT_FOUND = 4100,
    /**
     * TLS certificates failed to load
     */
    TLS_CERTIFICATES_INVALID = 4101,
    /**
     * TLS keys not found
     */
    TLS_KEYS_NOT_FOUND = 4102,
    /**
     * Failed to create TLS config
     */
    TLS_CONFIG_ERROR = 4103,
    /**
     * Failed to install virtual filesystem driver
     */
    VFS_DRIVER_INSTALL_ERROR = 4104,
    /**
     * Unspecified virtual filesystem error
     */
    VFS_OTHER_ERROR = 4105,
    /**
     * Another instance of the service is already running
     */
    SERVICE_ALREADY_RUNNING = 4106,
    /**
     * Store directory is not specified
     */
    STORE_DIR_UNSPECIFIED = 4107,
    /**
     * Mount directory is not specified
     */
    MOUNT_DIR_UNSPECIFIED = 4108,
    /**
     * Unspecified error
     */
    OTHER = 65535,
};
} // namespace error

const char* error_message(error::Service ec) noexcept;


enum LogLevel : uint8_t {
    ERROR = 1,
    WARN = 2,
    INFO = 3,
    DEBUG = 4,
    TRACE = 5,
};


struct MessageId {
    uint64_t value;
};

/**
 * Edit of a single metadata entry.
 */
struct MetadataEdit {
    std::string key;
    std::optional<std::string> old_value;
    std::optional<std::string> new_value;
};

/**
 * Default network parameters
 */
struct NetworkDefaults {
    std::vector<std::string> bind;
    bool port_forwarding_enabled;
    bool local_discovery_enabled;
};

struct DirectoryEntry {
    std::string name;
    EntryType entry_type;
};

struct QuotaInfo {
    std::optional<StorageSize> quota;
    StorageSize size;
};

struct FileHandle {
    size_t value;
};

struct RepositoryHandle {
    size_t value;
};

} // namespace ouisync
