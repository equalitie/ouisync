// This file is auto generated. Do not edit.

#pragma once

#include <cstdint>
#include <list>
#include <optional>
#include <memory>
#include <sstream>
#include <chrono>
#include <variant>

namespace ouisync {


/**
 * Symmetric encryption/decryption secret key.
 *
 * Note: this implementation tries to prevent certain types of attacks by making sure the
 * underlying sensitive key material is always stored at most in one place. This is achieved by
 * putting it on the heap which means it is not moved when the key itself is moved which could
 * otherwise leave a copy of the data in memory. Additionally, the data is behind a `Arc` which
 * means the key can be cheaply cloned without actually cloning the data. Finally, the data is
 * scrambled (overwritten with zeros) when the key is dropped to make sure it does not stay in
 * the memory past its lifetime.
 */
struct SecretKey {
    std::vector<uint8_t> value;
};

/**
 * A simple wrapper over String to avoid certain kinds of attack. For more elaboration please see
 * the documentation for the SecretKey structure.
 */
struct Password {
    std::string value;
};

struct PasswordSalt {
    std::vector<uint8_t> value;
};

/**
 * Strongly typed storage size.
 */
struct StorageSize {
    uint64_t bytes;
};

/**
 * Access mode of a repository.
 */
enum class AccessMode : uint8_t {
    /**
     * Repository is neither readable not writtable (but can still be synced).
     */
    blind = 0,
    /**
     * Repository is readable but not writtable.
     */
    read = 1,
    /**
     * Repository is both readable and writable.
     */
    write = 2,
};


/**
 * Type of secret to unlock a repository.
 */
struct LocalSecret {
    /**
     * Password provided by the user
     */
    struct Password {
        ouisync::Password value;
    };

    /**
     * Secret key generated by secure means (e.g., crypto-secure RNG, KDF, ...)
     */
    struct SecretKey {
        ouisync::SecretKey value;
    };

    using Alternatives = std::variant<
        Password,
        SecretKey
    >;

    Alternatives value;

    LocalSecret() = default;
    LocalSecret(LocalSecret&&) = default;
    LocalSecret& operator=(LocalSecret&&) = default;
    LocalSecret(LocalSecret const&) = default;

    template<class T>
    requires(!std::same_as<std::remove_cvref_t<T>, LocalSecret>)
    LocalSecret(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }
};

/**
 * Used to set or change the read or write local secret of a repository.
 */
struct SetLocalSecret {
    /**
     * Password provided by the user
     */
    struct Password {
        ouisync::Password value;
    };

    /**
     * Use to directly (without doing password hashing) set the `SecretKey` and `PasswordSalt` for
     * read or write access.
     */
    struct KeyAndSalt {
        ouisync::SecretKey key;
        ouisync::PasswordSalt salt;
    };

    using Alternatives = std::variant<
        Password,
        KeyAndSalt
    >;

    Alternatives value;

    SetLocalSecret() = default;
    SetLocalSecret(SetLocalSecret&&) = default;
    SetLocalSecret& operator=(SetLocalSecret&&) = default;
    SetLocalSecret(SetLocalSecret const&) = default;

    template<class T>
    requires(!std::same_as<std::remove_cvref_t<T>, SetLocalSecret>)
    SetLocalSecret(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }
};

/**
 * Token to share a repository. It can be encoded as a URL-formatted string and transmitted to
 * other replicas.
 */
struct ShareToken {
    std::string value;
};

/**
 * How to change access to a repository.
 */
struct AccessChange {
    /**
     * Enable read or write access, optionally with local secret
     */
    struct Enable {
        std::optional<ouisync::SetLocalSecret> value;
    };

    /**
     * Disable access
     */
    struct Disable {
    };

    using Alternatives = std::variant<
        Enable,
        Disable
    >;

    Alternatives value;

    AccessChange() = default;
    AccessChange(AccessChange&&) = default;
    AccessChange& operator=(AccessChange&&) = default;
    AccessChange(AccessChange const&) = default;

    template<class T>
    requires(!std::same_as<std::remove_cvref_t<T>, AccessChange>)
    AccessChange(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }
};

/**
 * Type of filesystem entry.
 */
enum class EntryType : uint8_t {
    file = 1,
    directory = 2,
};


/**
 * Network notification event.
 */
enum class NetworkEvent : uint8_t {
    /**
     * A peer has appeared with higher protocol version than us. Probably means we are using
     * outdated library. This event can be used to notify the user that they should update the app.
     */
    protocol_version_mismatch = 0,
    /**
     * The set of known peers has changed (e.g., a new peer has been discovered)
     */
    peer_set_change = 1,
};


/**
 * How was the peer discovered.
 */
enum class PeerSource : uint8_t {
    /**
     * Explicitly added by the user.
     */
    user_provided = 0,
    /**
     * Peer connected to us.
     */
    listener = 1,
    /**
     * Discovered on the Local Discovery.
     */
    local_discovery = 2,
    /**
     * Discovered on the DHT.
     */
    dht = 3,
    /**
     * Discovered on the Peer Exchange.
     */
    peer_exchange = 4,
};


struct PublicRuntimeId {
    std::vector<uint8_t> value;
};

struct PeerState {
    struct Known {
    };

    struct Connecting {
    };

    struct Handshaking {
    };

    struct Active {
        ouisync::PublicRuntimeId id;
        std::chrono::time_point<std::chrono::system_clock> since;
    };

    using Alternatives = std::variant<
        Known,
        Connecting,
        Handshaking,
        Active
    >;

    Alternatives value;

    PeerState() = default;
    PeerState(PeerState&&) = default;
    PeerState& operator=(PeerState&&) = default;
    PeerState(PeerState const&) = default;

    template<class T>
    requires(!std::same_as<std::remove_cvref_t<T>, PeerState>)
    PeerState(T&& v)
        : value(std::forward<T>(v)) {}

    template<class T>
    T& get() {
        return std::get<T>(value);
    }

    template<class T>
    T* get_if() {
        return std::get_if<T>(&value);
    }
};

/**
 * Network traffic statistics.
 */
struct Stats {
    uint64_t bytes_tx;
    uint64_t bytes_rx;
    uint64_t throughput_tx;
    uint64_t throughput_rx;
};

/**
 * Information about a peer.
 */
struct PeerInfo {
    std::string addr;
    PeerSource source;
    PeerState state;
    Stats stats;
};

/**
 * Progress of a task.
 */
struct Progress {
    uint64_t value;
    uint64_t total;
};

enum class NatBehavior : uint8_t {
    endpoint_independent = 0,
    address_dependent = 1,
    address_and_port_dependent = 2,
};


namespace error {
enum class Service : uint16_t {
    /**
     * No error
     */
    ok = 0,
    /**
     * Insuficient permission to perform the intended operation
     */
    permission_denied = 1,
    /**
     * Invalid input parameter
     */
    invalid_input = 2,
    /**
     * Invalid data (e.g., malformed incoming message, config file, etc...)
     */
    invalid_data = 3,
    /**
     * Entry already exists
     */
    already_exists = 4,
    /**
     * Entry not found
     */
    not_found = 5,
    /**
     * Multiple matching entries found
     */
    ambiguous = 6,
    /**
     * The indended operation is not supported
     */
    unsupported = 8,
    /**
     * The operation was interrupted
     */
    interrupted = 9,
    /**
     * Failed to establish connection to the server
     */
    connection_refused = 1025,
    /**
     * Connection aborted by the server
     */
    connection_aborted = 1026,
    /**
     * Failed to send or receive message
     */
    transport_error = 1027,
    /**
     * Listener failed to bind to the specified address
     */
    listener_bind_error = 1028,
    /**
     * Listener failed to accept client connection
     */
    listener_accept_error = 1029,
    /**
     * Operation on the internal repository store failed
     */
    store_error = 2049,
    /**
     * Entry was expected to not be a directory but it is
     */
    is_directory = 2050,
    /**
     * Entry was expected to be a directory but it isn't
     */
    not_directory = 2051,
    /**
     * Directory was expected to be empty but it isn't
     */
    directory_not_empty = 2052,
    /**
     * File or directory is busy
     */
    resource_busy = 2053,
    /**
     * Failed to initialize runtime
     */
    runtime_initialize_error = 4097,
    /**
     * Failed to read from or write into the config file
     */
    config_error = 4099,
    /**
     * TLS certificated not found
     */
    tls_certificates_not_found = 4100,
    /**
     * TLS certificates failed to load
     */
    tls_certificates_invalid = 4101,
    /**
     * TLS keys not found
     */
    tls_keys_not_found = 4102,
    /**
     * Failed to create TLS config
     */
    tls_config_error = 4103,
    /**
     * Failed to install virtual filesystem driver
     */
    vfs_driver_install_error = 4104,
    /**
     * Unspecified virtual filesystem error
     */
    vfs_other_error = 4105,
    /**
     * Another instance of the service is already running
     */
    service_already_running = 4106,
    /**
     * Store directory is not specified
     */
    store_dir_unspecified = 4107,
    /**
     * Mount directory is not specified
     */
    mount_dir_unspecified = 4108,
    /**
     * Ouisync compiled without VFS
     */
    no_vfs = 4109,
    /**
     * Unspecified error
     */
    other = 65535,
};
} // namespace error

const char* error_message(error::Service ec) noexcept;


enum class LogLevel : uint8_t {
    error = 1,
    warn = 2,
    info = 3,
    debug = 4,
    trace = 5,
};


struct MessageId {
    uint64_t value;
};

/**
 * Edit of a single metadata entry.
 */
struct MetadataEdit {
    std::string key;
    std::optional<std::string> old_value;
    std::optional<std::string> new_value;
};

/**
 * Default network parameters
 */
struct NetworkDefaults {
    std::vector<std::string> bind;
    bool port_forwarding_enabled;
    bool local_discovery_enabled;
};

struct DirectoryEntry {
    std::string name;
    EntryType entry_type;
};

struct QuotaInfo {
    std::optional<StorageSize> quota;
    StorageSize size;
};

struct FileHandle {
    size_t value;
};

struct RepositoryHandle {
    size_t value;
};

} // namespace ouisync
